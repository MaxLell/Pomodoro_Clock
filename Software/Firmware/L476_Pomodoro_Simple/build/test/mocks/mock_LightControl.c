/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_LightControl.h"

static const char* CMockString_LightControl_endSequence = "LightControl_endSequence";
static const char* CMockString_LightControl_execute = "LightControl_execute";
static const char* CMockString_LightControl_fillLedToColorArray = "LightControl_fillLedToColorArray";
static const char* CMockString_LightControl_fillMinuteToColorArray = "LightControl_fillMinuteToColorArray";
static const char* CMockString_LightControl_init = "LightControl_init";
static const char* CMockString_LightControl_removeColorsFromMinuteArray = "LightControl_removeColorsFromMinuteArray";
static const char* CMockString_LightControl_runSequence = "LightControl_runSequence";
static const char* CMockString_LightControl_sequenceIsCompleted = "LightControl_sequenceIsCompleted";
static const char* CMockString_LightControl_setLedsToColor = "LightControl_setLedsToColor";
static const char* CMockString_in_au8LedToColorArray = "in_au8LedToColorArray";
static const char* CMockString_in_au8MinuteToColorArray = "in_au8MinuteToColorArray";
static const char* CMockString_in_u8BreaktimeIntervalMin = "in_u8BreaktimeIntervalMin";
static const char* CMockString_in_u8CurrentMinute = "in_u8CurrentMinute";
static const char* CMockString_in_u8WorktimeIntervalMin = "in_u8WorktimeIntervalMin";
static const char* CMockString_inout_au8ColorArray = "inout_au8ColorArray";
static const char* CMockString_inout_au8LedToColorArray = "inout_au8LedToColorArray";
static const char* CMockString_inout_au8MinuteToColorArray = "inout_au8MinuteToColorArray";
static const char* CMockString_out_bSequenceIsCompleted = "out_bSequenceIsCompleted";

typedef struct _CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  status_t ReturnVal;
  int CallOrder;
  uint8_t Expected_in_u8CurrentMinute;
  uint8_t Expected_in_u8WorktimeIntervalMin;
  uint8_t Expected_in_u8BreaktimeIntervalMin;
  uint8_t* Expected_inout_au8ColorArray;
  char ReturnThruPtr_inout_au8ColorArray_Used;
  uint8_t* ReturnThruPtr_inout_au8ColorArray_Val;
  size_t ReturnThruPtr_inout_au8ColorArray_Size;
  char IgnoreArg_in_u8CurrentMinute;
  char IgnoreArg_in_u8WorktimeIntervalMin;
  char IgnoreArg_in_u8BreaktimeIntervalMin;
  char IgnoreArg_inout_au8ColorArray;

} CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE;

typedef struct _CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  status_t ReturnVal;
  int CallOrder;
  uint8_t* Expected_inout_au8MinuteToColorArray;
  uint8_t Expected_in_u8CurrentMinute;
  char ReturnThruPtr_inout_au8MinuteToColorArray_Used;
  uint8_t* ReturnThruPtr_inout_au8MinuteToColorArray_Val;
  size_t ReturnThruPtr_inout_au8MinuteToColorArray_Size;
  char IgnoreArg_inout_au8MinuteToColorArray;
  char IgnoreArg_in_u8CurrentMinute;

} CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE;

typedef struct _CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  status_t ReturnVal;
  int CallOrder;
  uint8_t* Expected_in_au8MinuteToColorArray;
  uint8_t* Expected_inout_au8LedToColorArray;
  char ReturnThruPtr_in_au8MinuteToColorArray_Used;
  uint8_t* ReturnThruPtr_in_au8MinuteToColorArray_Val;
  size_t ReturnThruPtr_in_au8MinuteToColorArray_Size;
  char ReturnThruPtr_inout_au8LedToColorArray_Used;
  uint8_t* ReturnThruPtr_inout_au8LedToColorArray_Val;
  size_t ReturnThruPtr_inout_au8LedToColorArray_Size;
  char IgnoreArg_in_au8MinuteToColorArray;
  char IgnoreArg_inout_au8LedToColorArray;

} CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE;

typedef struct _CMOCK_LightControl_setLedsToColor_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  status_t ReturnVal;
  int CallOrder;
  uint8_t* Expected_in_au8LedToColorArray;
  char ReturnThruPtr_in_au8LedToColorArray_Used;
  uint8_t* ReturnThruPtr_in_au8LedToColorArray_Val;
  size_t ReturnThruPtr_in_au8LedToColorArray_Size;
  char IgnoreArg_in_au8LedToColorArray;

} CMOCK_LightControl_setLedsToColor_CALL_INSTANCE;

typedef struct _CMOCK_LightControl_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  status_t ReturnVal;
  int CallOrder;
  uint8_t Expected_in_u8CurrentMinute;
  char IgnoreArg_in_u8CurrentMinute;

} CMOCK_LightControl_init_CALL_INSTANCE;

typedef struct _CMOCK_LightControl_endSequence_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  status_t ReturnVal;
  int CallOrder;

} CMOCK_LightControl_endSequence_CALL_INSTANCE;

typedef struct _CMOCK_LightControl_runSequence_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  status_t ReturnVal;
  int CallOrder;
  uint8_t Expected_in_u8CurrentMinute;
  char IgnoreArg_in_u8CurrentMinute;

} CMOCK_LightControl_runSequence_CALL_INSTANCE;

typedef struct _CMOCK_LightControl_execute_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  status_t ReturnVal;
  int CallOrder;
  uint8_t Expected_in_u8CurrentMinute;
  char IgnoreArg_in_u8CurrentMinute;

} CMOCK_LightControl_execute_CALL_INSTANCE;

typedef struct _CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  status_t ReturnVal;
  int CallOrder;
  BOOL* Expected_out_bSequenceIsCompleted;
  char ReturnThruPtr_out_bSequenceIsCompleted_Used;
  BOOL* ReturnThruPtr_out_bSequenceIsCompleted_Val;
  size_t ReturnThruPtr_out_bSequenceIsCompleted_Size;
  char IgnoreArg_out_bSequenceIsCompleted;

} CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE;

static struct mock_LightControlInstance
{
  char LightControl_fillMinuteToColorArray_IgnoreBool;
  status_t LightControl_fillMinuteToColorArray_FinalReturn;
  char LightControl_fillMinuteToColorArray_CallbackBool;
  CMOCK_LightControl_fillMinuteToColorArray_CALLBACK LightControl_fillMinuteToColorArray_CallbackFunctionPointer;
  int LightControl_fillMinuteToColorArray_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE LightControl_fillMinuteToColorArray_CallInstance;
  char LightControl_removeColorsFromMinuteArray_IgnoreBool;
  status_t LightControl_removeColorsFromMinuteArray_FinalReturn;
  char LightControl_removeColorsFromMinuteArray_CallbackBool;
  CMOCK_LightControl_removeColorsFromMinuteArray_CALLBACK LightControl_removeColorsFromMinuteArray_CallbackFunctionPointer;
  int LightControl_removeColorsFromMinuteArray_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE LightControl_removeColorsFromMinuteArray_CallInstance;
  char LightControl_fillLedToColorArray_IgnoreBool;
  status_t LightControl_fillLedToColorArray_FinalReturn;
  char LightControl_fillLedToColorArray_CallbackBool;
  CMOCK_LightControl_fillLedToColorArray_CALLBACK LightControl_fillLedToColorArray_CallbackFunctionPointer;
  int LightControl_fillLedToColorArray_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE LightControl_fillLedToColorArray_CallInstance;
  char LightControl_setLedsToColor_IgnoreBool;
  status_t LightControl_setLedsToColor_FinalReturn;
  char LightControl_setLedsToColor_CallbackBool;
  CMOCK_LightControl_setLedsToColor_CALLBACK LightControl_setLedsToColor_CallbackFunctionPointer;
  int LightControl_setLedsToColor_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE LightControl_setLedsToColor_CallInstance;
  char LightControl_init_IgnoreBool;
  status_t LightControl_init_FinalReturn;
  char LightControl_init_CallbackBool;
  CMOCK_LightControl_init_CALLBACK LightControl_init_CallbackFunctionPointer;
  int LightControl_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE LightControl_init_CallInstance;
  char LightControl_endSequence_IgnoreBool;
  status_t LightControl_endSequence_FinalReturn;
  char LightControl_endSequence_CallbackBool;
  CMOCK_LightControl_endSequence_CALLBACK LightControl_endSequence_CallbackFunctionPointer;
  int LightControl_endSequence_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE LightControl_endSequence_CallInstance;
  char LightControl_runSequence_IgnoreBool;
  status_t LightControl_runSequence_FinalReturn;
  char LightControl_runSequence_CallbackBool;
  CMOCK_LightControl_runSequence_CALLBACK LightControl_runSequence_CallbackFunctionPointer;
  int LightControl_runSequence_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE LightControl_runSequence_CallInstance;
  char LightControl_execute_IgnoreBool;
  status_t LightControl_execute_FinalReturn;
  char LightControl_execute_CallbackBool;
  CMOCK_LightControl_execute_CALLBACK LightControl_execute_CallbackFunctionPointer;
  int LightControl_execute_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE LightControl_execute_CallInstance;
  char LightControl_sequenceIsCompleted_IgnoreBool;
  status_t LightControl_sequenceIsCompleted_FinalReturn;
  char LightControl_sequenceIsCompleted_CallbackBool;
  CMOCK_LightControl_sequenceIsCompleted_CALLBACK LightControl_sequenceIsCompleted_CallbackFunctionPointer;
  int LightControl_sequenceIsCompleted_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE LightControl_sequenceIsCompleted_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_LightControl_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.LightControl_fillMinuteToColorArray_CallInstance;
  if (Mock.LightControl_fillMinuteToColorArray_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_LightControl_fillMinuteToColorArray);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.LightControl_fillMinuteToColorArray_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.LightControl_removeColorsFromMinuteArray_CallInstance;
  if (Mock.LightControl_removeColorsFromMinuteArray_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_LightControl_removeColorsFromMinuteArray);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.LightControl_removeColorsFromMinuteArray_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.LightControl_fillLedToColorArray_CallInstance;
  if (Mock.LightControl_fillLedToColorArray_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_LightControl_fillLedToColorArray);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.LightControl_fillLedToColorArray_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.LightControl_setLedsToColor_CallInstance;
  if (Mock.LightControl_setLedsToColor_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_LightControl_setLedsToColor);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.LightControl_setLedsToColor_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.LightControl_init_CallInstance;
  if (Mock.LightControl_init_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_LightControl_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.LightControl_init_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.LightControl_endSequence_CallInstance;
  if (Mock.LightControl_endSequence_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_LightControl_endSequence);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.LightControl_endSequence_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.LightControl_runSequence_CallInstance;
  if (Mock.LightControl_runSequence_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_LightControl_runSequence);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.LightControl_runSequence_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.LightControl_execute_CallInstance;
  if (Mock.LightControl_execute_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_LightControl_execute);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.LightControl_execute_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.LightControl_sequenceIsCompleted_CallInstance;
  if (Mock.LightControl_sequenceIsCompleted_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_LightControl_sequenceIsCompleted);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.LightControl_sequenceIsCompleted_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_LightControl_Init(void)
{
  mock_LightControl_Destroy();
}

void mock_LightControl_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

status_t LightControl_fillMinuteToColorArray(uint8_t in_u8CurrentMinute, uint8_t in_u8WorktimeIntervalMin, uint8_t in_u8BreaktimeIntervalMin, uint8_t* inout_au8ColorArray)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_LightControl_fillMinuteToColorArray);
  cmock_call_instance = (CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.LightControl_fillMinuteToColorArray_CallInstance);
  Mock.LightControl_fillMinuteToColorArray_CallInstance = CMock_Guts_MemNext(Mock.LightControl_fillMinuteToColorArray_CallInstance);
  if (Mock.LightControl_fillMinuteToColorArray_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.LightControl_fillMinuteToColorArray_FinalReturn;
    memcpy((void*)(&Mock.LightControl_fillMinuteToColorArray_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.LightControl_fillMinuteToColorArray_CallbackBool &&
      Mock.LightControl_fillMinuteToColorArray_CallbackFunctionPointer != NULL)
  {
    status_t cmock_cb_ret = Mock.LightControl_fillMinuteToColorArray_CallbackFunctionPointer(in_u8CurrentMinute, in_u8WorktimeIntervalMin, in_u8BreaktimeIntervalMin, inout_au8ColorArray, Mock.LightControl_fillMinuteToColorArray_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_in_u8CurrentMinute)
  {
    UNITY_SET_DETAILS(CMockString_LightControl_fillMinuteToColorArray,CMockString_in_u8CurrentMinute);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_in_u8CurrentMinute, in_u8CurrentMinute, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_in_u8WorktimeIntervalMin)
  {
    UNITY_SET_DETAILS(CMockString_LightControl_fillMinuteToColorArray,CMockString_in_u8WorktimeIntervalMin);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_in_u8WorktimeIntervalMin, in_u8WorktimeIntervalMin, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_in_u8BreaktimeIntervalMin)
  {
    UNITY_SET_DETAILS(CMockString_LightControl_fillMinuteToColorArray,CMockString_in_u8BreaktimeIntervalMin);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_in_u8BreaktimeIntervalMin, in_u8BreaktimeIntervalMin, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_inout_au8ColorArray)
  {
    UNITY_SET_DETAILS(CMockString_LightControl_fillMinuteToColorArray,CMockString_inout_au8ColorArray);
    if (cmock_call_instance->Expected_inout_au8ColorArray == NULL)
      { UNITY_TEST_ASSERT_NULL(inout_au8ColorArray, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_inout_au8ColorArray, inout_au8ColorArray, 1, cmock_line, CMockStringMismatch); }
  }
  if (Mock.LightControl_fillMinuteToColorArray_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.LightControl_fillMinuteToColorArray_CallbackFunctionPointer(in_u8CurrentMinute, in_u8WorktimeIntervalMin, in_u8BreaktimeIntervalMin, inout_au8ColorArray, Mock.LightControl_fillMinuteToColorArray_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_inout_au8ColorArray_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(inout_au8ColorArray, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)inout_au8ColorArray, (void*)cmock_call_instance->ReturnThruPtr_inout_au8ColorArray_Val,
      cmock_call_instance->ReturnThruPtr_inout_au8ColorArray_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_LightControl_fillMinuteToColorArray(CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE* cmock_call_instance, uint8_t in_u8CurrentMinute, uint8_t in_u8WorktimeIntervalMin, uint8_t in_u8BreaktimeIntervalMin, uint8_t* inout_au8ColorArray);
void CMockExpectParameters_LightControl_fillMinuteToColorArray(CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE* cmock_call_instance, uint8_t in_u8CurrentMinute, uint8_t in_u8WorktimeIntervalMin, uint8_t in_u8BreaktimeIntervalMin, uint8_t* inout_au8ColorArray)
{
  cmock_call_instance->Expected_in_u8CurrentMinute = in_u8CurrentMinute;
  cmock_call_instance->IgnoreArg_in_u8CurrentMinute = 0;
  cmock_call_instance->Expected_in_u8WorktimeIntervalMin = in_u8WorktimeIntervalMin;
  cmock_call_instance->IgnoreArg_in_u8WorktimeIntervalMin = 0;
  cmock_call_instance->Expected_in_u8BreaktimeIntervalMin = in_u8BreaktimeIntervalMin;
  cmock_call_instance->IgnoreArg_in_u8BreaktimeIntervalMin = 0;
  cmock_call_instance->Expected_inout_au8ColorArray = inout_au8ColorArray;
  cmock_call_instance->IgnoreArg_inout_au8ColorArray = 0;
  cmock_call_instance->ReturnThruPtr_inout_au8ColorArray_Used = 0;
}

void LightControl_fillMinuteToColorArray_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE));
  CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_fillMinuteToColorArray_CallInstance = CMock_Guts_MemChain(Mock.LightControl_fillMinuteToColorArray_CallInstance, cmock_guts_index);
  Mock.LightControl_fillMinuteToColorArray_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.LightControl_fillMinuteToColorArray_IgnoreBool = (char)1;
}

void LightControl_fillMinuteToColorArray_CMockStopIgnore(void)
{
  if(Mock.LightControl_fillMinuteToColorArray_IgnoreBool)
    Mock.LightControl_fillMinuteToColorArray_CallInstance = CMock_Guts_MemNext(Mock.LightControl_fillMinuteToColorArray_CallInstance);
  Mock.LightControl_fillMinuteToColorArray_IgnoreBool = (char)0;
}

void LightControl_fillMinuteToColorArray_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t in_u8CurrentMinute, uint8_t in_u8WorktimeIntervalMin, uint8_t in_u8BreaktimeIntervalMin, uint8_t* inout_au8ColorArray, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE));
  CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_fillMinuteToColorArray_CallInstance = CMock_Guts_MemChain(Mock.LightControl_fillMinuteToColorArray_CallInstance, cmock_guts_index);
  Mock.LightControl_fillMinuteToColorArray_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_LightControl_fillMinuteToColorArray(cmock_call_instance, in_u8CurrentMinute, in_u8WorktimeIntervalMin, in_u8BreaktimeIntervalMin, inout_au8ColorArray);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(status_t[sizeof(cmock_to_return) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
}

void LightControl_fillMinuteToColorArray_AddCallback(CMOCK_LightControl_fillMinuteToColorArray_CALLBACK Callback)
{
  Mock.LightControl_fillMinuteToColorArray_IgnoreBool = (char)0;
  Mock.LightControl_fillMinuteToColorArray_CallbackBool = (char)1;
  Mock.LightControl_fillMinuteToColorArray_CallbackFunctionPointer = Callback;
}

void LightControl_fillMinuteToColorArray_Stub(CMOCK_LightControl_fillMinuteToColorArray_CALLBACK Callback)
{
  Mock.LightControl_fillMinuteToColorArray_IgnoreBool = (char)0;
  Mock.LightControl_fillMinuteToColorArray_CallbackBool = (char)0;
  Mock.LightControl_fillMinuteToColorArray_CallbackFunctionPointer = Callback;
}

void LightControl_fillMinuteToColorArray_CMockReturnMemThruPtr_inout_au8ColorArray(UNITY_LINE_TYPE cmock_line, uint8_t* inout_au8ColorArray, size_t cmock_size)
{
  CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_fillMinuteToColorArray_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_inout_au8ColorArray_Used = 1;
  cmock_call_instance->ReturnThruPtr_inout_au8ColorArray_Val = inout_au8ColorArray;
  cmock_call_instance->ReturnThruPtr_inout_au8ColorArray_Size = cmock_size;
}

void LightControl_fillMinuteToColorArray_CMockIgnoreArg_in_u8CurrentMinute(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_fillMinuteToColorArray_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_in_u8CurrentMinute = 1;
}

void LightControl_fillMinuteToColorArray_CMockIgnoreArg_in_u8WorktimeIntervalMin(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_fillMinuteToColorArray_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_in_u8WorktimeIntervalMin = 1;
}

void LightControl_fillMinuteToColorArray_CMockIgnoreArg_in_u8BreaktimeIntervalMin(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_fillMinuteToColorArray_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_in_u8BreaktimeIntervalMin = 1;
}

void LightControl_fillMinuteToColorArray_CMockIgnoreArg_inout_au8ColorArray(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_fillMinuteToColorArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_fillMinuteToColorArray_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_inout_au8ColorArray = 1;
}

status_t LightControl_removeColorsFromMinuteArray(uint8_t* inout_au8MinuteToColorArray, uint8_t in_u8CurrentMinute)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_LightControl_removeColorsFromMinuteArray);
  cmock_call_instance = (CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.LightControl_removeColorsFromMinuteArray_CallInstance);
  Mock.LightControl_removeColorsFromMinuteArray_CallInstance = CMock_Guts_MemNext(Mock.LightControl_removeColorsFromMinuteArray_CallInstance);
  if (Mock.LightControl_removeColorsFromMinuteArray_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.LightControl_removeColorsFromMinuteArray_FinalReturn;
    memcpy((void*)(&Mock.LightControl_removeColorsFromMinuteArray_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.LightControl_removeColorsFromMinuteArray_CallbackBool &&
      Mock.LightControl_removeColorsFromMinuteArray_CallbackFunctionPointer != NULL)
  {
    status_t cmock_cb_ret = Mock.LightControl_removeColorsFromMinuteArray_CallbackFunctionPointer(inout_au8MinuteToColorArray, in_u8CurrentMinute, Mock.LightControl_removeColorsFromMinuteArray_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_inout_au8MinuteToColorArray)
  {
    UNITY_SET_DETAILS(CMockString_LightControl_removeColorsFromMinuteArray,CMockString_inout_au8MinuteToColorArray);
    if (cmock_call_instance->Expected_inout_au8MinuteToColorArray == NULL)
      { UNITY_TEST_ASSERT_NULL(inout_au8MinuteToColorArray, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_inout_au8MinuteToColorArray, inout_au8MinuteToColorArray, 1, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_in_u8CurrentMinute)
  {
    UNITY_SET_DETAILS(CMockString_LightControl_removeColorsFromMinuteArray,CMockString_in_u8CurrentMinute);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_in_u8CurrentMinute, in_u8CurrentMinute, cmock_line, CMockStringMismatch);
  }
  if (Mock.LightControl_removeColorsFromMinuteArray_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.LightControl_removeColorsFromMinuteArray_CallbackFunctionPointer(inout_au8MinuteToColorArray, in_u8CurrentMinute, Mock.LightControl_removeColorsFromMinuteArray_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_inout_au8MinuteToColorArray_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(inout_au8MinuteToColorArray, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)inout_au8MinuteToColorArray, (void*)cmock_call_instance->ReturnThruPtr_inout_au8MinuteToColorArray_Val,
      cmock_call_instance->ReturnThruPtr_inout_au8MinuteToColorArray_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_LightControl_removeColorsFromMinuteArray(CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE* cmock_call_instance, uint8_t* inout_au8MinuteToColorArray, uint8_t in_u8CurrentMinute);
void CMockExpectParameters_LightControl_removeColorsFromMinuteArray(CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE* cmock_call_instance, uint8_t* inout_au8MinuteToColorArray, uint8_t in_u8CurrentMinute)
{
  cmock_call_instance->Expected_inout_au8MinuteToColorArray = inout_au8MinuteToColorArray;
  cmock_call_instance->IgnoreArg_inout_au8MinuteToColorArray = 0;
  cmock_call_instance->ReturnThruPtr_inout_au8MinuteToColorArray_Used = 0;
  cmock_call_instance->Expected_in_u8CurrentMinute = in_u8CurrentMinute;
  cmock_call_instance->IgnoreArg_in_u8CurrentMinute = 0;
}

void LightControl_removeColorsFromMinuteArray_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE));
  CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_removeColorsFromMinuteArray_CallInstance = CMock_Guts_MemChain(Mock.LightControl_removeColorsFromMinuteArray_CallInstance, cmock_guts_index);
  Mock.LightControl_removeColorsFromMinuteArray_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.LightControl_removeColorsFromMinuteArray_IgnoreBool = (char)1;
}

void LightControl_removeColorsFromMinuteArray_CMockStopIgnore(void)
{
  if(Mock.LightControl_removeColorsFromMinuteArray_IgnoreBool)
    Mock.LightControl_removeColorsFromMinuteArray_CallInstance = CMock_Guts_MemNext(Mock.LightControl_removeColorsFromMinuteArray_CallInstance);
  Mock.LightControl_removeColorsFromMinuteArray_IgnoreBool = (char)0;
}

void LightControl_removeColorsFromMinuteArray_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* inout_au8MinuteToColorArray, uint8_t in_u8CurrentMinute, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE));
  CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_removeColorsFromMinuteArray_CallInstance = CMock_Guts_MemChain(Mock.LightControl_removeColorsFromMinuteArray_CallInstance, cmock_guts_index);
  Mock.LightControl_removeColorsFromMinuteArray_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_LightControl_removeColorsFromMinuteArray(cmock_call_instance, inout_au8MinuteToColorArray, in_u8CurrentMinute);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(status_t[sizeof(cmock_to_return) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
}

void LightControl_removeColorsFromMinuteArray_AddCallback(CMOCK_LightControl_removeColorsFromMinuteArray_CALLBACK Callback)
{
  Mock.LightControl_removeColorsFromMinuteArray_IgnoreBool = (char)0;
  Mock.LightControl_removeColorsFromMinuteArray_CallbackBool = (char)1;
  Mock.LightControl_removeColorsFromMinuteArray_CallbackFunctionPointer = Callback;
}

void LightControl_removeColorsFromMinuteArray_Stub(CMOCK_LightControl_removeColorsFromMinuteArray_CALLBACK Callback)
{
  Mock.LightControl_removeColorsFromMinuteArray_IgnoreBool = (char)0;
  Mock.LightControl_removeColorsFromMinuteArray_CallbackBool = (char)0;
  Mock.LightControl_removeColorsFromMinuteArray_CallbackFunctionPointer = Callback;
}

void LightControl_removeColorsFromMinuteArray_CMockReturnMemThruPtr_inout_au8MinuteToColorArray(UNITY_LINE_TYPE cmock_line, uint8_t* inout_au8MinuteToColorArray, size_t cmock_size)
{
  CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_removeColorsFromMinuteArray_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_inout_au8MinuteToColorArray_Used = 1;
  cmock_call_instance->ReturnThruPtr_inout_au8MinuteToColorArray_Val = inout_au8MinuteToColorArray;
  cmock_call_instance->ReturnThruPtr_inout_au8MinuteToColorArray_Size = cmock_size;
}

void LightControl_removeColorsFromMinuteArray_CMockIgnoreArg_inout_au8MinuteToColorArray(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_removeColorsFromMinuteArray_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_inout_au8MinuteToColorArray = 1;
}

void LightControl_removeColorsFromMinuteArray_CMockIgnoreArg_in_u8CurrentMinute(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_removeColorsFromMinuteArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_removeColorsFromMinuteArray_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_in_u8CurrentMinute = 1;
}

status_t LightControl_fillLedToColorArray(uint8_t* in_au8MinuteToColorArray, uint8_t* inout_au8LedToColorArray)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_LightControl_fillLedToColorArray);
  cmock_call_instance = (CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.LightControl_fillLedToColorArray_CallInstance);
  Mock.LightControl_fillLedToColorArray_CallInstance = CMock_Guts_MemNext(Mock.LightControl_fillLedToColorArray_CallInstance);
  if (Mock.LightControl_fillLedToColorArray_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.LightControl_fillLedToColorArray_FinalReturn;
    memcpy((void*)(&Mock.LightControl_fillLedToColorArray_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.LightControl_fillLedToColorArray_CallbackBool &&
      Mock.LightControl_fillLedToColorArray_CallbackFunctionPointer != NULL)
  {
    status_t cmock_cb_ret = Mock.LightControl_fillLedToColorArray_CallbackFunctionPointer(in_au8MinuteToColorArray, inout_au8LedToColorArray, Mock.LightControl_fillLedToColorArray_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_in_au8MinuteToColorArray)
  {
    UNITY_SET_DETAILS(CMockString_LightControl_fillLedToColorArray,CMockString_in_au8MinuteToColorArray);
    if (cmock_call_instance->Expected_in_au8MinuteToColorArray == NULL)
      { UNITY_TEST_ASSERT_NULL(in_au8MinuteToColorArray, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_in_au8MinuteToColorArray, in_au8MinuteToColorArray, 1, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_inout_au8LedToColorArray)
  {
    UNITY_SET_DETAILS(CMockString_LightControl_fillLedToColorArray,CMockString_inout_au8LedToColorArray);
    if (cmock_call_instance->Expected_inout_au8LedToColorArray == NULL)
      { UNITY_TEST_ASSERT_NULL(inout_au8LedToColorArray, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_inout_au8LedToColorArray, inout_au8LedToColorArray, 1, cmock_line, CMockStringMismatch); }
  }
  if (Mock.LightControl_fillLedToColorArray_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.LightControl_fillLedToColorArray_CallbackFunctionPointer(in_au8MinuteToColorArray, inout_au8LedToColorArray, Mock.LightControl_fillLedToColorArray_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_in_au8MinuteToColorArray_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(in_au8MinuteToColorArray, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)in_au8MinuteToColorArray, (void*)cmock_call_instance->ReturnThruPtr_in_au8MinuteToColorArray_Val,
      cmock_call_instance->ReturnThruPtr_in_au8MinuteToColorArray_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_inout_au8LedToColorArray_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(inout_au8LedToColorArray, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)inout_au8LedToColorArray, (void*)cmock_call_instance->ReturnThruPtr_inout_au8LedToColorArray_Val,
      cmock_call_instance->ReturnThruPtr_inout_au8LedToColorArray_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_LightControl_fillLedToColorArray(CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE* cmock_call_instance, uint8_t* in_au8MinuteToColorArray, uint8_t* inout_au8LedToColorArray);
void CMockExpectParameters_LightControl_fillLedToColorArray(CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE* cmock_call_instance, uint8_t* in_au8MinuteToColorArray, uint8_t* inout_au8LedToColorArray)
{
  cmock_call_instance->Expected_in_au8MinuteToColorArray = in_au8MinuteToColorArray;
  cmock_call_instance->IgnoreArg_in_au8MinuteToColorArray = 0;
  cmock_call_instance->ReturnThruPtr_in_au8MinuteToColorArray_Used = 0;
  cmock_call_instance->Expected_inout_au8LedToColorArray = inout_au8LedToColorArray;
  cmock_call_instance->IgnoreArg_inout_au8LedToColorArray = 0;
  cmock_call_instance->ReturnThruPtr_inout_au8LedToColorArray_Used = 0;
}

void LightControl_fillLedToColorArray_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE));
  CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_fillLedToColorArray_CallInstance = CMock_Guts_MemChain(Mock.LightControl_fillLedToColorArray_CallInstance, cmock_guts_index);
  Mock.LightControl_fillLedToColorArray_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.LightControl_fillLedToColorArray_IgnoreBool = (char)1;
}

void LightControl_fillLedToColorArray_CMockStopIgnore(void)
{
  if(Mock.LightControl_fillLedToColorArray_IgnoreBool)
    Mock.LightControl_fillLedToColorArray_CallInstance = CMock_Guts_MemNext(Mock.LightControl_fillLedToColorArray_CallInstance);
  Mock.LightControl_fillLedToColorArray_IgnoreBool = (char)0;
}

void LightControl_fillLedToColorArray_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* in_au8MinuteToColorArray, uint8_t* inout_au8LedToColorArray, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE));
  CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_fillLedToColorArray_CallInstance = CMock_Guts_MemChain(Mock.LightControl_fillLedToColorArray_CallInstance, cmock_guts_index);
  Mock.LightControl_fillLedToColorArray_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_LightControl_fillLedToColorArray(cmock_call_instance, in_au8MinuteToColorArray, inout_au8LedToColorArray);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(status_t[sizeof(cmock_to_return) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
}

void LightControl_fillLedToColorArray_AddCallback(CMOCK_LightControl_fillLedToColorArray_CALLBACK Callback)
{
  Mock.LightControl_fillLedToColorArray_IgnoreBool = (char)0;
  Mock.LightControl_fillLedToColorArray_CallbackBool = (char)1;
  Mock.LightControl_fillLedToColorArray_CallbackFunctionPointer = Callback;
}

void LightControl_fillLedToColorArray_Stub(CMOCK_LightControl_fillLedToColorArray_CALLBACK Callback)
{
  Mock.LightControl_fillLedToColorArray_IgnoreBool = (char)0;
  Mock.LightControl_fillLedToColorArray_CallbackBool = (char)0;
  Mock.LightControl_fillLedToColorArray_CallbackFunctionPointer = Callback;
}

void LightControl_fillLedToColorArray_CMockReturnMemThruPtr_in_au8MinuteToColorArray(UNITY_LINE_TYPE cmock_line, uint8_t* in_au8MinuteToColorArray, size_t cmock_size)
{
  CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_fillLedToColorArray_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_in_au8MinuteToColorArray_Used = 1;
  cmock_call_instance->ReturnThruPtr_in_au8MinuteToColorArray_Val = in_au8MinuteToColorArray;
  cmock_call_instance->ReturnThruPtr_in_au8MinuteToColorArray_Size = cmock_size;
}

void LightControl_fillLedToColorArray_CMockReturnMemThruPtr_inout_au8LedToColorArray(UNITY_LINE_TYPE cmock_line, uint8_t* inout_au8LedToColorArray, size_t cmock_size)
{
  CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_fillLedToColorArray_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_inout_au8LedToColorArray_Used = 1;
  cmock_call_instance->ReturnThruPtr_inout_au8LedToColorArray_Val = inout_au8LedToColorArray;
  cmock_call_instance->ReturnThruPtr_inout_au8LedToColorArray_Size = cmock_size;
}

void LightControl_fillLedToColorArray_CMockIgnoreArg_in_au8MinuteToColorArray(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_fillLedToColorArray_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_in_au8MinuteToColorArray = 1;
}

void LightControl_fillLedToColorArray_CMockIgnoreArg_inout_au8LedToColorArray(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_fillLedToColorArray_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_fillLedToColorArray_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_inout_au8LedToColorArray = 1;
}

status_t LightControl_setLedsToColor(uint8_t* in_au8LedToColorArray)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_LightControl_setLedsToColor_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_LightControl_setLedsToColor);
  cmock_call_instance = (CMOCK_LightControl_setLedsToColor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.LightControl_setLedsToColor_CallInstance);
  Mock.LightControl_setLedsToColor_CallInstance = CMock_Guts_MemNext(Mock.LightControl_setLedsToColor_CallInstance);
  if (Mock.LightControl_setLedsToColor_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.LightControl_setLedsToColor_FinalReturn;
    memcpy((void*)(&Mock.LightControl_setLedsToColor_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.LightControl_setLedsToColor_CallbackBool &&
      Mock.LightControl_setLedsToColor_CallbackFunctionPointer != NULL)
  {
    status_t cmock_cb_ret = Mock.LightControl_setLedsToColor_CallbackFunctionPointer(in_au8LedToColorArray, Mock.LightControl_setLedsToColor_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_in_au8LedToColorArray)
  {
    UNITY_SET_DETAILS(CMockString_LightControl_setLedsToColor,CMockString_in_au8LedToColorArray);
    if (cmock_call_instance->Expected_in_au8LedToColorArray == NULL)
      { UNITY_TEST_ASSERT_NULL(in_au8LedToColorArray, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_in_au8LedToColorArray, in_au8LedToColorArray, 1, cmock_line, CMockStringMismatch); }
  }
  if (Mock.LightControl_setLedsToColor_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.LightControl_setLedsToColor_CallbackFunctionPointer(in_au8LedToColorArray, Mock.LightControl_setLedsToColor_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_in_au8LedToColorArray_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(in_au8LedToColorArray, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)in_au8LedToColorArray, (void*)cmock_call_instance->ReturnThruPtr_in_au8LedToColorArray_Val,
      cmock_call_instance->ReturnThruPtr_in_au8LedToColorArray_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_LightControl_setLedsToColor(CMOCK_LightControl_setLedsToColor_CALL_INSTANCE* cmock_call_instance, uint8_t* in_au8LedToColorArray);
void CMockExpectParameters_LightControl_setLedsToColor(CMOCK_LightControl_setLedsToColor_CALL_INSTANCE* cmock_call_instance, uint8_t* in_au8LedToColorArray)
{
  cmock_call_instance->Expected_in_au8LedToColorArray = in_au8LedToColorArray;
  cmock_call_instance->IgnoreArg_in_au8LedToColorArray = 0;
  cmock_call_instance->ReturnThruPtr_in_au8LedToColorArray_Used = 0;
}

void LightControl_setLedsToColor_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_setLedsToColor_CALL_INSTANCE));
  CMOCK_LightControl_setLedsToColor_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_setLedsToColor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_setLedsToColor_CallInstance = CMock_Guts_MemChain(Mock.LightControl_setLedsToColor_CallInstance, cmock_guts_index);
  Mock.LightControl_setLedsToColor_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.LightControl_setLedsToColor_IgnoreBool = (char)1;
}

void LightControl_setLedsToColor_CMockStopIgnore(void)
{
  if(Mock.LightControl_setLedsToColor_IgnoreBool)
    Mock.LightControl_setLedsToColor_CallInstance = CMock_Guts_MemNext(Mock.LightControl_setLedsToColor_CallInstance);
  Mock.LightControl_setLedsToColor_IgnoreBool = (char)0;
}

void LightControl_setLedsToColor_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* in_au8LedToColorArray, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_setLedsToColor_CALL_INSTANCE));
  CMOCK_LightControl_setLedsToColor_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_setLedsToColor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_setLedsToColor_CallInstance = CMock_Guts_MemChain(Mock.LightControl_setLedsToColor_CallInstance, cmock_guts_index);
  Mock.LightControl_setLedsToColor_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_LightControl_setLedsToColor(cmock_call_instance, in_au8LedToColorArray);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(status_t[sizeof(cmock_to_return) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
}

void LightControl_setLedsToColor_AddCallback(CMOCK_LightControl_setLedsToColor_CALLBACK Callback)
{
  Mock.LightControl_setLedsToColor_IgnoreBool = (char)0;
  Mock.LightControl_setLedsToColor_CallbackBool = (char)1;
  Mock.LightControl_setLedsToColor_CallbackFunctionPointer = Callback;
}

void LightControl_setLedsToColor_Stub(CMOCK_LightControl_setLedsToColor_CALLBACK Callback)
{
  Mock.LightControl_setLedsToColor_IgnoreBool = (char)0;
  Mock.LightControl_setLedsToColor_CallbackBool = (char)0;
  Mock.LightControl_setLedsToColor_CallbackFunctionPointer = Callback;
}

void LightControl_setLedsToColor_CMockReturnMemThruPtr_in_au8LedToColorArray(UNITY_LINE_TYPE cmock_line, uint8_t* in_au8LedToColorArray, size_t cmock_size)
{
  CMOCK_LightControl_setLedsToColor_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_setLedsToColor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_setLedsToColor_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_in_au8LedToColorArray_Used = 1;
  cmock_call_instance->ReturnThruPtr_in_au8LedToColorArray_Val = in_au8LedToColorArray;
  cmock_call_instance->ReturnThruPtr_in_au8LedToColorArray_Size = cmock_size;
}

void LightControl_setLedsToColor_CMockIgnoreArg_in_au8LedToColorArray(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_LightControl_setLedsToColor_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_setLedsToColor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_setLedsToColor_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_in_au8LedToColorArray = 1;
}

status_t LightControl_init(uint8_t in_u8CurrentMinute)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_LightControl_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_LightControl_init);
  cmock_call_instance = (CMOCK_LightControl_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.LightControl_init_CallInstance);
  Mock.LightControl_init_CallInstance = CMock_Guts_MemNext(Mock.LightControl_init_CallInstance);
  if (Mock.LightControl_init_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.LightControl_init_FinalReturn;
    memcpy((void*)(&Mock.LightControl_init_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.LightControl_init_CallbackBool &&
      Mock.LightControl_init_CallbackFunctionPointer != NULL)
  {
    status_t cmock_cb_ret = Mock.LightControl_init_CallbackFunctionPointer(in_u8CurrentMinute, Mock.LightControl_init_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_in_u8CurrentMinute)
  {
    UNITY_SET_DETAILS(CMockString_LightControl_init,CMockString_in_u8CurrentMinute);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_in_u8CurrentMinute, in_u8CurrentMinute, cmock_line, CMockStringMismatch);
  }
  if (Mock.LightControl_init_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.LightControl_init_CallbackFunctionPointer(in_u8CurrentMinute, Mock.LightControl_init_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_LightControl_init(CMOCK_LightControl_init_CALL_INSTANCE* cmock_call_instance, uint8_t in_u8CurrentMinute);
void CMockExpectParameters_LightControl_init(CMOCK_LightControl_init_CALL_INSTANCE* cmock_call_instance, uint8_t in_u8CurrentMinute)
{
  cmock_call_instance->Expected_in_u8CurrentMinute = in_u8CurrentMinute;
  cmock_call_instance->IgnoreArg_in_u8CurrentMinute = 0;
}

void LightControl_init_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_init_CALL_INSTANCE));
  CMOCK_LightControl_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_init_CallInstance = CMock_Guts_MemChain(Mock.LightControl_init_CallInstance, cmock_guts_index);
  Mock.LightControl_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.LightControl_init_IgnoreBool = (char)1;
}

void LightControl_init_CMockStopIgnore(void)
{
  if(Mock.LightControl_init_IgnoreBool)
    Mock.LightControl_init_CallInstance = CMock_Guts_MemNext(Mock.LightControl_init_CallInstance);
  Mock.LightControl_init_IgnoreBool = (char)0;
}

void LightControl_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t in_u8CurrentMinute, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_init_CALL_INSTANCE));
  CMOCK_LightControl_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_init_CallInstance = CMock_Guts_MemChain(Mock.LightControl_init_CallInstance, cmock_guts_index);
  Mock.LightControl_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_LightControl_init(cmock_call_instance, in_u8CurrentMinute);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(status_t[sizeof(cmock_to_return) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
}

void LightControl_init_AddCallback(CMOCK_LightControl_init_CALLBACK Callback)
{
  Mock.LightControl_init_IgnoreBool = (char)0;
  Mock.LightControl_init_CallbackBool = (char)1;
  Mock.LightControl_init_CallbackFunctionPointer = Callback;
}

void LightControl_init_Stub(CMOCK_LightControl_init_CALLBACK Callback)
{
  Mock.LightControl_init_IgnoreBool = (char)0;
  Mock.LightControl_init_CallbackBool = (char)0;
  Mock.LightControl_init_CallbackFunctionPointer = Callback;
}

void LightControl_init_CMockIgnoreArg_in_u8CurrentMinute(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_LightControl_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_init_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_in_u8CurrentMinute = 1;
}

status_t LightControl_endSequence(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_LightControl_endSequence_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_LightControl_endSequence);
  cmock_call_instance = (CMOCK_LightControl_endSequence_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.LightControl_endSequence_CallInstance);
  Mock.LightControl_endSequence_CallInstance = CMock_Guts_MemNext(Mock.LightControl_endSequence_CallInstance);
  if (Mock.LightControl_endSequence_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.LightControl_endSequence_FinalReturn;
    memcpy((void*)(&Mock.LightControl_endSequence_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.LightControl_endSequence_CallbackBool &&
      Mock.LightControl_endSequence_CallbackFunctionPointer != NULL)
  {
    status_t cmock_cb_ret = Mock.LightControl_endSequence_CallbackFunctionPointer(Mock.LightControl_endSequence_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.LightControl_endSequence_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.LightControl_endSequence_CallbackFunctionPointer(Mock.LightControl_endSequence_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void LightControl_endSequence_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_endSequence_CALL_INSTANCE));
  CMOCK_LightControl_endSequence_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_endSequence_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_endSequence_CallInstance = CMock_Guts_MemChain(Mock.LightControl_endSequence_CallInstance, cmock_guts_index);
  Mock.LightControl_endSequence_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.LightControl_endSequence_IgnoreBool = (char)1;
}

void LightControl_endSequence_CMockStopIgnore(void)
{
  if(Mock.LightControl_endSequence_IgnoreBool)
    Mock.LightControl_endSequence_CallInstance = CMock_Guts_MemNext(Mock.LightControl_endSequence_CallInstance);
  Mock.LightControl_endSequence_IgnoreBool = (char)0;
}

void LightControl_endSequence_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_endSequence_CALL_INSTANCE));
  CMOCK_LightControl_endSequence_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_endSequence_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_endSequence_CallInstance = CMock_Guts_MemChain(Mock.LightControl_endSequence_CallInstance, cmock_guts_index);
  Mock.LightControl_endSequence_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(status_t[sizeof(cmock_to_return) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
}

void LightControl_endSequence_AddCallback(CMOCK_LightControl_endSequence_CALLBACK Callback)
{
  Mock.LightControl_endSequence_IgnoreBool = (char)0;
  Mock.LightControl_endSequence_CallbackBool = (char)1;
  Mock.LightControl_endSequence_CallbackFunctionPointer = Callback;
}

void LightControl_endSequence_Stub(CMOCK_LightControl_endSequence_CALLBACK Callback)
{
  Mock.LightControl_endSequence_IgnoreBool = (char)0;
  Mock.LightControl_endSequence_CallbackBool = (char)0;
  Mock.LightControl_endSequence_CallbackFunctionPointer = Callback;
}

status_t LightControl_runSequence(uint8_t in_u8CurrentMinute)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_LightControl_runSequence_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_LightControl_runSequence);
  cmock_call_instance = (CMOCK_LightControl_runSequence_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.LightControl_runSequence_CallInstance);
  Mock.LightControl_runSequence_CallInstance = CMock_Guts_MemNext(Mock.LightControl_runSequence_CallInstance);
  if (Mock.LightControl_runSequence_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.LightControl_runSequence_FinalReturn;
    memcpy((void*)(&Mock.LightControl_runSequence_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.LightControl_runSequence_CallbackBool &&
      Mock.LightControl_runSequence_CallbackFunctionPointer != NULL)
  {
    status_t cmock_cb_ret = Mock.LightControl_runSequence_CallbackFunctionPointer(in_u8CurrentMinute, Mock.LightControl_runSequence_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_in_u8CurrentMinute)
  {
    UNITY_SET_DETAILS(CMockString_LightControl_runSequence,CMockString_in_u8CurrentMinute);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_in_u8CurrentMinute, in_u8CurrentMinute, cmock_line, CMockStringMismatch);
  }
  if (Mock.LightControl_runSequence_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.LightControl_runSequence_CallbackFunctionPointer(in_u8CurrentMinute, Mock.LightControl_runSequence_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_LightControl_runSequence(CMOCK_LightControl_runSequence_CALL_INSTANCE* cmock_call_instance, uint8_t in_u8CurrentMinute);
void CMockExpectParameters_LightControl_runSequence(CMOCK_LightControl_runSequence_CALL_INSTANCE* cmock_call_instance, uint8_t in_u8CurrentMinute)
{
  cmock_call_instance->Expected_in_u8CurrentMinute = in_u8CurrentMinute;
  cmock_call_instance->IgnoreArg_in_u8CurrentMinute = 0;
}

void LightControl_runSequence_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_runSequence_CALL_INSTANCE));
  CMOCK_LightControl_runSequence_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_runSequence_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_runSequence_CallInstance = CMock_Guts_MemChain(Mock.LightControl_runSequence_CallInstance, cmock_guts_index);
  Mock.LightControl_runSequence_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.LightControl_runSequence_IgnoreBool = (char)1;
}

void LightControl_runSequence_CMockStopIgnore(void)
{
  if(Mock.LightControl_runSequence_IgnoreBool)
    Mock.LightControl_runSequence_CallInstance = CMock_Guts_MemNext(Mock.LightControl_runSequence_CallInstance);
  Mock.LightControl_runSequence_IgnoreBool = (char)0;
}

void LightControl_runSequence_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t in_u8CurrentMinute, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_runSequence_CALL_INSTANCE));
  CMOCK_LightControl_runSequence_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_runSequence_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_runSequence_CallInstance = CMock_Guts_MemChain(Mock.LightControl_runSequence_CallInstance, cmock_guts_index);
  Mock.LightControl_runSequence_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_LightControl_runSequence(cmock_call_instance, in_u8CurrentMinute);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(status_t[sizeof(cmock_to_return) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
}

void LightControl_runSequence_AddCallback(CMOCK_LightControl_runSequence_CALLBACK Callback)
{
  Mock.LightControl_runSequence_IgnoreBool = (char)0;
  Mock.LightControl_runSequence_CallbackBool = (char)1;
  Mock.LightControl_runSequence_CallbackFunctionPointer = Callback;
}

void LightControl_runSequence_Stub(CMOCK_LightControl_runSequence_CALLBACK Callback)
{
  Mock.LightControl_runSequence_IgnoreBool = (char)0;
  Mock.LightControl_runSequence_CallbackBool = (char)0;
  Mock.LightControl_runSequence_CallbackFunctionPointer = Callback;
}

void LightControl_runSequence_CMockIgnoreArg_in_u8CurrentMinute(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_LightControl_runSequence_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_runSequence_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_runSequence_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_in_u8CurrentMinute = 1;
}

status_t LightControl_execute(uint8_t in_u8CurrentMinute)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_LightControl_execute_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_LightControl_execute);
  cmock_call_instance = (CMOCK_LightControl_execute_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.LightControl_execute_CallInstance);
  Mock.LightControl_execute_CallInstance = CMock_Guts_MemNext(Mock.LightControl_execute_CallInstance);
  if (Mock.LightControl_execute_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.LightControl_execute_FinalReturn;
    memcpy((void*)(&Mock.LightControl_execute_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.LightControl_execute_CallbackBool &&
      Mock.LightControl_execute_CallbackFunctionPointer != NULL)
  {
    status_t cmock_cb_ret = Mock.LightControl_execute_CallbackFunctionPointer(in_u8CurrentMinute, Mock.LightControl_execute_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_in_u8CurrentMinute)
  {
    UNITY_SET_DETAILS(CMockString_LightControl_execute,CMockString_in_u8CurrentMinute);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_in_u8CurrentMinute, in_u8CurrentMinute, cmock_line, CMockStringMismatch);
  }
  if (Mock.LightControl_execute_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.LightControl_execute_CallbackFunctionPointer(in_u8CurrentMinute, Mock.LightControl_execute_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_LightControl_execute(CMOCK_LightControl_execute_CALL_INSTANCE* cmock_call_instance, uint8_t in_u8CurrentMinute);
void CMockExpectParameters_LightControl_execute(CMOCK_LightControl_execute_CALL_INSTANCE* cmock_call_instance, uint8_t in_u8CurrentMinute)
{
  cmock_call_instance->Expected_in_u8CurrentMinute = in_u8CurrentMinute;
  cmock_call_instance->IgnoreArg_in_u8CurrentMinute = 0;
}

void LightControl_execute_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_execute_CALL_INSTANCE));
  CMOCK_LightControl_execute_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_execute_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_execute_CallInstance = CMock_Guts_MemChain(Mock.LightControl_execute_CallInstance, cmock_guts_index);
  Mock.LightControl_execute_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.LightControl_execute_IgnoreBool = (char)1;
}

void LightControl_execute_CMockStopIgnore(void)
{
  if(Mock.LightControl_execute_IgnoreBool)
    Mock.LightControl_execute_CallInstance = CMock_Guts_MemNext(Mock.LightControl_execute_CallInstance);
  Mock.LightControl_execute_IgnoreBool = (char)0;
}

void LightControl_execute_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t in_u8CurrentMinute, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_execute_CALL_INSTANCE));
  CMOCK_LightControl_execute_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_execute_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_execute_CallInstance = CMock_Guts_MemChain(Mock.LightControl_execute_CallInstance, cmock_guts_index);
  Mock.LightControl_execute_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_LightControl_execute(cmock_call_instance, in_u8CurrentMinute);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(status_t[sizeof(cmock_to_return) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
}

void LightControl_execute_AddCallback(CMOCK_LightControl_execute_CALLBACK Callback)
{
  Mock.LightControl_execute_IgnoreBool = (char)0;
  Mock.LightControl_execute_CallbackBool = (char)1;
  Mock.LightControl_execute_CallbackFunctionPointer = Callback;
}

void LightControl_execute_Stub(CMOCK_LightControl_execute_CALLBACK Callback)
{
  Mock.LightControl_execute_IgnoreBool = (char)0;
  Mock.LightControl_execute_CallbackBool = (char)0;
  Mock.LightControl_execute_CallbackFunctionPointer = Callback;
}

void LightControl_execute_CMockIgnoreArg_in_u8CurrentMinute(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_LightControl_execute_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_execute_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_execute_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_in_u8CurrentMinute = 1;
}

status_t LightControl_sequenceIsCompleted(BOOL* out_bSequenceIsCompleted)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_LightControl_sequenceIsCompleted);
  cmock_call_instance = (CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.LightControl_sequenceIsCompleted_CallInstance);
  Mock.LightControl_sequenceIsCompleted_CallInstance = CMock_Guts_MemNext(Mock.LightControl_sequenceIsCompleted_CallInstance);
  if (Mock.LightControl_sequenceIsCompleted_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.LightControl_sequenceIsCompleted_FinalReturn;
    memcpy((void*)(&Mock.LightControl_sequenceIsCompleted_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.LightControl_sequenceIsCompleted_CallbackBool &&
      Mock.LightControl_sequenceIsCompleted_CallbackFunctionPointer != NULL)
  {
    status_t cmock_cb_ret = Mock.LightControl_sequenceIsCompleted_CallbackFunctionPointer(out_bSequenceIsCompleted, Mock.LightControl_sequenceIsCompleted_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_out_bSequenceIsCompleted)
  {
    UNITY_SET_DETAILS(CMockString_LightControl_sequenceIsCompleted,CMockString_out_bSequenceIsCompleted);
    if (cmock_call_instance->Expected_out_bSequenceIsCompleted == NULL)
      { UNITY_TEST_ASSERT_NULL(out_bSequenceIsCompleted, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_out_bSequenceIsCompleted, out_bSequenceIsCompleted, 1, cmock_line, CMockStringMismatch); }
  }
  if (Mock.LightControl_sequenceIsCompleted_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.LightControl_sequenceIsCompleted_CallbackFunctionPointer(out_bSequenceIsCompleted, Mock.LightControl_sequenceIsCompleted_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_out_bSequenceIsCompleted_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(out_bSequenceIsCompleted, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)out_bSequenceIsCompleted, (void*)cmock_call_instance->ReturnThruPtr_out_bSequenceIsCompleted_Val,
      cmock_call_instance->ReturnThruPtr_out_bSequenceIsCompleted_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_LightControl_sequenceIsCompleted(CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE* cmock_call_instance, BOOL* out_bSequenceIsCompleted);
void CMockExpectParameters_LightControl_sequenceIsCompleted(CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE* cmock_call_instance, BOOL* out_bSequenceIsCompleted)
{
  cmock_call_instance->Expected_out_bSequenceIsCompleted = out_bSequenceIsCompleted;
  cmock_call_instance->IgnoreArg_out_bSequenceIsCompleted = 0;
  cmock_call_instance->ReturnThruPtr_out_bSequenceIsCompleted_Used = 0;
}

void LightControl_sequenceIsCompleted_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE));
  CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_sequenceIsCompleted_CallInstance = CMock_Guts_MemChain(Mock.LightControl_sequenceIsCompleted_CallInstance, cmock_guts_index);
  Mock.LightControl_sequenceIsCompleted_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.LightControl_sequenceIsCompleted_IgnoreBool = (char)1;
}

void LightControl_sequenceIsCompleted_CMockStopIgnore(void)
{
  if(Mock.LightControl_sequenceIsCompleted_IgnoreBool)
    Mock.LightControl_sequenceIsCompleted_CallInstance = CMock_Guts_MemNext(Mock.LightControl_sequenceIsCompleted_CallInstance);
  Mock.LightControl_sequenceIsCompleted_IgnoreBool = (char)0;
}

void LightControl_sequenceIsCompleted_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BOOL* out_bSequenceIsCompleted, status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE));
  CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.LightControl_sequenceIsCompleted_CallInstance = CMock_Guts_MemChain(Mock.LightControl_sequenceIsCompleted_CallInstance, cmock_guts_index);
  Mock.LightControl_sequenceIsCompleted_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_LightControl_sequenceIsCompleted(cmock_call_instance, out_bSequenceIsCompleted);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(status_t[sizeof(cmock_to_return) == sizeof(status_t) ? 1 : -1])); /* add status_t to :treat_as_array if this causes an error */
}

void LightControl_sequenceIsCompleted_AddCallback(CMOCK_LightControl_sequenceIsCompleted_CALLBACK Callback)
{
  Mock.LightControl_sequenceIsCompleted_IgnoreBool = (char)0;
  Mock.LightControl_sequenceIsCompleted_CallbackBool = (char)1;
  Mock.LightControl_sequenceIsCompleted_CallbackFunctionPointer = Callback;
}

void LightControl_sequenceIsCompleted_Stub(CMOCK_LightControl_sequenceIsCompleted_CALLBACK Callback)
{
  Mock.LightControl_sequenceIsCompleted_IgnoreBool = (char)0;
  Mock.LightControl_sequenceIsCompleted_CallbackBool = (char)0;
  Mock.LightControl_sequenceIsCompleted_CallbackFunctionPointer = Callback;
}

void LightControl_sequenceIsCompleted_CMockReturnMemThruPtr_out_bSequenceIsCompleted(UNITY_LINE_TYPE cmock_line, BOOL* out_bSequenceIsCompleted, size_t cmock_size)
{
  CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_sequenceIsCompleted_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_out_bSequenceIsCompleted_Used = 1;
  cmock_call_instance->ReturnThruPtr_out_bSequenceIsCompleted_Val = out_bSequenceIsCompleted;
  cmock_call_instance->ReturnThruPtr_out_bSequenceIsCompleted_Size = cmock_size;
}

void LightControl_sequenceIsCompleted_CMockIgnoreArg_out_bSequenceIsCompleted(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE* cmock_call_instance = (CMOCK_LightControl_sequenceIsCompleted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.LightControl_sequenceIsCompleted_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_out_bSequenceIsCompleted = 1;
}

